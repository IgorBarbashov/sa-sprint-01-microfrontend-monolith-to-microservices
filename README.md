## Задание 1 - разделение проекта Mesto на несколько микрофронтендов
- Анализ проекта
  - [Функциональность Mesto](#01-00-functional-requirements)
  - [Структура проекта](#01-00-project-structure)
  - [Маршрутизация](#01-00-routing)
  - [Стили и их организация](#01-00-styles)
  - [Примечания](#01-00-notes)

---

### <p id="01-00-functional-requirements">Анализ: Функциональность Mesto</p>

1. Загрузка фотографий
   - Нажимаем кнопку "Добавить фото" -> Открывается модалка
     - Нажимаем кнопку "Сохранить" -> Карточка фото появляется в начале Списка карточек на главной странице + Модалка закрывается
     - Нажимаем иконку "Закрыть" -> Модалка закрывается

2. Удаление фотографий
    - Нажимаем иконку "Удалить фото" на Карточке фото -> Карточка фото исчезает из Списка карточек

3. Сбор и учёт лайков под фото
    - Нажимаем иконку "Лайк" на Карточке фото -> Иконка лайк меняет свое значение на противоположное (active <-> inactive)

4. Создание профиля и его редактирование
    - Нажимаем на кнопку "Редактировать профиль" -> Открывается модалка "Редактировать профиль"
        - Нажимаем кнопку "Сохранить" -> Изменения отображаются в профиле пользавателя на главной странице + Модалка закрывается
        - Нажимаем иконку "Закрыть" -> Модалка закрывается

---

### <p id="01-00-project-structure">Анализ: Структура проекта</p>

```markdown
/public         Статика для сборки приложения
/src            
  /blocks       CSS-стили компонентов приложения
  /components   React-компоненты. Есть компоненты реализующую конкретную функциональность приложения,
                есть - сервисные, что-то вроде layout'ов, используемые для компоновки блоков верхнего уровня. 
  /contexts     Объект Context. Выполняет роль глобального состояния приложения. Хранит данные о текущем пользователе
  /images       Иконки из UI-Kit. Есть неиспользуемые файлы
  /utils        Сервисы для работы с API. Уже разделены на два: для авторизации и для работы с профилем/карточками фото
  /vendor       Глобальные настройки CSS-стилей
index.css       Точка входа для подключения CSS-стилей
index.js        Entrypoint всего приложения
```

---

### <p id="01-00-routing">Анализ: Маршрутизация</p>

- `index.js`: `BrowserRouter` провайдер
- `App.js`: роутинг для отрисовки контента страницы
  - если роут строго равен `/` (главная страница), отрисовывается компонент `ProtectedRoute`
  - либо отрисовывает компоненты `Register` / `Login` в зависимости от роута
- `ProtectedRoute.js`: управляет маршрутизацией на основе данных о входе в систему
  - если выполнен вход в систему, отрисовывает компонент `Main`
  - если вход не выполнен, делает переадресацию на роут `/signin` для отрисовки компонента `Login`
- `Register.js`: есть ссылка на роут `/signin` для отрисовки компонента `Login`
- `Header.js`: роутинг в заголовке страницы
  - если выполнен вход в систему, отображает данные пользователя
  - если вход не выполнен, реализует взаимную перелинковку роутов `/signin` и `/signup`

---

### <p id="01-00-styles">Анализ: Стили и их организация</p>

- CSS-стили подключаются глобально, пре/пост процессоры не используются
- Наименования стилей составлены по методологии БЭМ, что решает проблему коллизии имен при глобальном подключении стилей
- Стили декомпозированы по компонентному принципу - в каждой папке стили, которые относятся к одному компоненту
- `Login.js` импортирует свой css-файл напрямую, но какого-то смысла в этом не вижу (тем более что файл пустой). Надо будет привести к общему способу подключения
- `/vendor` - глобальные настройки подключения css-стилей (сброс предустановленных стилей агентов, подключение шрифтов)
- `index.css` в корне проекта - точка входя для подключения всех стилей приложения 

---

### <p id="01-00-notes">Анализ: Примечания</p>
- сама модалка может быть частью микрофронтенда `UI-Kit` выделенного в npm-пакет для переиспользования в разных приложениях
- продумать момент, что у нас есть глобальные настройки css-стилей (как вариант это может быть частью корпоративного `UI-Kit` в отдельном npm-пакете)
  - мы хотим чтобы они применялись при разработке, запуске, тестировании каждого микрофронтенда отдельно
  - мы не хотим чтобы у нас дублировалась кодовая база в микрофронтендах