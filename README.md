## Задание 1 - разделение проекта Mesto на несколько микрофронтендов

- [Анализ проекта (отдельный файл)](frontend/microfrontend/README.md)
- [Уровень 1. Проектирование](#01-01-design)

---

### <p id="01-01-design">Уровень 1 - Проектирование</p>

1. Предварительный анализ
   - [Анализ приложения (отдельный файл)](frontend/microfrontend/README.md)
   - Цель перехода:
     - На данный момент реализация приложения в виде монолита полностью удовлетворяет всем требованиям: простое приложение с ограниченной функциональностью и редкими обновлениями связанными с поддержкой существующей функциональности   
     - Есть бизнес-задача выхода на новые рынки, что влечет за собой разработку и оперативную доставку новой функциональности, обеспечение высокой отказоустойчивости работы приложения и быстрого исправления выявленных проблем. Обеспечение единого стиля корпоративных приложений.
     - **Исходя из бизнес-задач цели перехода на микрофронтендную архитектуру**:
       - Обеспечение независимой разработки отдельных модулей приложения, их автономных сборки, тестирования и деплоя
       - Возможность частых обновлений отдельных модулей приложения
       - Обеспечение возможности масштабирования отдельных модулей без влияния на другие части системы
   - Опыт команды: команда frontend-разработчиков со стажем 5+ лет на стеке React. Планируется набор разработчиков на том же стеке с разделением на небольшие команды с непересекающимися зонами ответственности за конкретный модуль приложения 

2. Бизнес-функции, которыми будут заниматься разные команды
   - Сервис авторизации пользователя
   - Управление профилем пользователя
   - Управление списком карточек фотографий
   - Так же будет отдельная команда, занимающаяся созданием корпоративного `UI-Kit`'а 

5. Выбор метода реализации
   - **Стратегия проектирования: гибридная** - вертикальная нарезка с максимально изолированными модулями и частично шаренными библиотеками
     - вертикальная нарезка в соответствии с бизнес-функциями, определенными в п.2, что позволит разрабатывать, тестировать и обновлять модули независимо от других
     - эта стратегия обеспечивает гибкость разработки при добавлении новых функций в приложение, создавая новые микрофронты
     - одновременно получаем возможность гибко масштабировать конкретные микрофронты при возрастающих нагрузках на отдельные части системы
     - изолированность микрофронтов позволяет производить независимое развертывание каждого модуля
     - шаринг библиотек позволяет избежать дублирования кода и уменьшить размер бандлов
     - для нас не важна автономность команд в плане технологического стека - вся кодовая база у нас на одном стеке React и в планах усиливать экспертизу в этом направлении
   - **Метод интеграции микрофронтендов: Run-time**
     - нам важно что разработка ведется отдельными командами с независимыми графиками развертывания
     - у нас есть необходимость динамически обновлять отдельные модули
     - внедряемое решение должно позволять масштабировать разные части приложения независимо
   - **Метод композиции микрофронтендов: клиентская компоновка** (с возможным дальнейшим переходом на гибридный подход)
     - в нашем приложении практически весь контент интерактивный и меняется в зависимости от действий с пользователя
     - контент у нас находится за авторизацией, значит нам не важно SEO и не критично время отдачи первой страницы

4. Инструмент для создания микрофронтендов - **Webpack Module Federation**
   - этот инструмент позволяет микрофронтендам динамически обмениваться зависимостями во время выполнения
   - так же есть возможность использования разных версий библиотек без конфликтов (следует учесть что такой подход увеличит размер бандлов)
   - т.к. стратегия проектирования у нас гибридная и предполагает, в т.ч., максимально возможную изоляцию микрофронтов, высока вероятность дублирования библиотек в каждом микрофронте. Эта проблема решается за счет использования sharing'а зависимостей (надо учесть при этом усложняется контроль версий библиотек)
   - Webpack Module Federation использует `lazy` и `Suspense` для оптимизации загрузок бандлов
   - Single SPA делает упор на бесшовной интеграции на основе маршрутизации и разнообразии фреймворков, но ни одна из этих возможностей не является для нас ключевой. Стек у нас един - React. С маршрутизацией тоже нет однозначного сопоставления `route - microfrontend`. Например, на главной странице `/` у нас должны монтироваться два микрофронта `Профиль пользователя` и `Список карточек фотографий`.

5. Стратегия коммуникации микрофронтендов (управление состоянием между микрофронтендами) - **Shared Context API**
   - изначально более подходящим выглядит подход `Pub/Sub` - он позволяет компонентам публиковать события при каком-то значимом действии. У нас, например, могут быть следующие события:
     - Сервис авторизации пользователя
       - пользователь залогинился - надо передать по шине `e-mail` логина в компонент `Header.js`
       - пользователь разлогинился - данных передавать не надо
     - Управление профилем пользователя
       - пользователь отредактировал профиль - данных передавать не надо
     - Управление списком карточек фотографий
       - пользователь добавил карточку - данных передавать не надо
       - пользователь удалил карточку - данных передавать не надо
       - пользователь изменил лайк на каротчке - данных передавать не надо
     
       Получается, нам надо отправить событие при одном действии - логин пользователя и подписчик будет тоже один - `Header.js`
   - но с другой стороны, данные полученные микрофронтендом `Профиль пользователя` используются и в других модулях
     - `Список карточек фотографий` - для управления действиями с лайками фоток
     
     т.о. у нас состояние одного микрофронтенда отражается/используется в нескольких компонентах интерфейса в других микрофронтедах.
     В таком случае предпочтительнее использовать глобальное состояние - в нашем случае достаточно Context API.
   - При выборе инструмента React Context API мы завязываемся на один стек - React и нам сложно будет вносить изменения если какой-то из микрофронтендов в будущем будет использовать другой фреймворк. Но это наше решение на стратегическом уровне, поэтому используем Context API 

